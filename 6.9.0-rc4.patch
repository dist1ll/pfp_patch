diff --git a/arch/x86/mm/fault.c b/arch/x86/mm/fault.c
index 622d12ec7..9d5ec6997 100644
--- a/arch/x86/mm/fault.c
+++ b/arch/x86/mm/fault.c
@@ -1360,9 +1360,10 @@ void do_user_addr_fault(struct pt_regs *regs,
 		goto lock_mmap;
 	}
 	fault = handle_mm_fault(vma, address, flags | FAULT_FLAG_VMA_LOCK, regs);
-	if (!(fault & (VM_FAULT_RETRY | VM_FAULT_COMPLETED)))
+	if (!(fault & (VM_FAULT_RETRY | VM_FAULT_COMPLETED))) {
 		vma_end_read(vma);
-
+	}
+	
 	if (!(fault & VM_FAULT_RETRY)) {
 		count_vm_vma_lock_event(VMA_LOCK_SUCCESS);
 		goto done;
@@ -1473,6 +1474,14 @@ void do_user_addr_fault(struct pt_regs *regs,
 		else
 			BUG();
 	}
+
+	/* After successful page fault, we can clear the page if the callee 
+	 * requested it. This avoids lock contention */
+	if (fault & VM_FAULT_CALLER_CLEARS) {
+		printk("clearing %luMB", (vma->vm_end - vma->vm_start) / 1000000);
+		// below is wrong
+		// memset((void*)vma->vm_start, 0, vma->vm_end - vma->vm_start);
+	}
 }
 NOKPROBE_SYMBOL(do_user_addr_fault);
 
diff --git a/include/linux/mm.h b/include/linux/mm.h
index 0436b919f..a536bffab 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -507,6 +507,17 @@ static inline bool fault_flag_allow_retry_first(enum fault_flag flags)
 	{ FAULT_FLAG_INTERRUPTIBLE,	"INTERRUPTIBLE" }, \
 	{ FAULT_FLAG_VMA_LOCK,		"VMA_LOCK" }
 
+
+/* A request by the pagefault handler to defer the page clearing to the caller.
+ * This is useful to avoid clearing pages deep in the pagefault handler, where
+ * we are likely to hold on to locks, which may cause contention.
+ *
+ * The struct contains a simple address range that should be cleared.
+ */
+struct vm_fault_doclear {
+	unsigned long from;
+	unsigned long to;
+}
 /*
  * vm_fault is filled by the pagefault handler and passed to the vma's
  * ->fault function. The vma's ->fault is responsible for returning a bitmask
diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h
index 5240bd7bc..d0e671c32 100644
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -1252,6 +1252,7 @@ enum vm_fault_reason {
 	VM_FAULT_DONE_COW       = (__force vm_fault_t)0x001000,
 	VM_FAULT_NEEDDSYNC      = (__force vm_fault_t)0x002000,
 	VM_FAULT_COMPLETED      = (__force vm_fault_t)0x004000,
+	VM_FAULT_CALLER_CLEARS  = (__force vm_fault_t)0x010000,
 	VM_FAULT_HINDEX_MASK    = (__force vm_fault_t)0x0f0000,
 };
 
@@ -1276,6 +1277,7 @@ enum vm_fault_reason {
 	{ VM_FAULT_FALLBACK,            "FALLBACK" },	\
 	{ VM_FAULT_DONE_COW,            "DONE_COW" },	\
 	{ VM_FAULT_NEEDDSYNC,           "NEEDDSYNC" },	\
+	{ VM_FAULT_CALLER_CLEARS,       "CALLER_CLEARS" },	\
 	{ VM_FAULT_COMPLETED,           "COMPLETED" }
 
 struct vm_special_mapping {
diff --git a/mm/hugetlb.c b/mm/hugetlb.c
index 23ef240ba..0b10878ab 100644
--- a/mm/hugetlb.c
+++ b/mm/hugetlb.c
@@ -6294,7 +6294,7 @@ static vm_fault_t hugetlb_no_page(struct mm_struct *mm,
 				ret = 0;
 			goto out;
 		}
-		clear_huge_page(&folio->page, address, pages_per_huge_page(h));
+		// clear_huge_page(&folio->page, address, pages_per_huge_page(h));
 		__folio_mark_uptodate(folio);
 		new_folio = true;
 
@@ -6385,6 +6385,7 @@ static vm_fault_t hugetlb_no_page(struct mm_struct *mm,
 	hugetlb_count_add(pages_per_huge_page(h), mm);
 	if ((flags & FAULT_FLAG_WRITE) && !(vma->vm_flags & VM_SHARED)) {
 		/* Optimization, do the COW without a second fault */
+		printk("cow optimization");
 		ret = hugetlb_wp(mm, vma, address, ptep, flags, folio, ptl, vmf);
 	}
 
@@ -6399,6 +6400,9 @@ static vm_fault_t hugetlb_no_page(struct mm_struct *mm,
 		folio_set_hugetlb_migratable(folio);
 
 	folio_unlock(folio);
+
+	/* Huge pages should be cleared outside the mm semaphore */
+	ret |= VM_FAULT_CALLER_CLEARS;
 out:
 	hugetlb_vma_unlock_read(vma);
 	mutex_unlock(&hugetlb_fault_mutex_table[hash]);
@@ -6511,7 +6515,7 @@ vm_fault_t hugetlb_fault(struct mm_struct *mm, struct vm_area_struct *vma,
 	}
 
 	ret = 0;
-
+	
 	/*
 	 * entry could be a migration/hwpoison entry at this point, so this
 	 * check prevents the kernel from going below assuming that we have
diff --git a/shell.nix b/shell.nix
index f9f706883..523efd53e 100644
--- a/shell.nix
+++ b/shell.nix
@@ -1,11 +1,27 @@
 { pkgs ? import <nixpkgs> {} }:
   pkgs.mkShell {
     nativeBuildInputs = with pkgs.buildPackages; [ 
+      pkg-config
       ncurses
       zlib
       elfutils
       openssl
       bc
       pahole
+      flex
+      bison
+      # for building tools
+      perl
+      python3
+      linuxKernel.packages.linux_6_8.systemtap
+      libcap
+      libbfd
+      readline
+      # llvmPackages_17.libllvm
+      llvmPackages_17.stdenv
+      bcc
+      cmake
+      libbpf
+      cereal
     ];
 }
diff --git a/tools/perf/check-headers.sh b/tools/perf/check-headers.sh
index 66ba33dbc..af066c116 100755
--- a/tools/perf/check-headers.sh
+++ b/tools/perf/check-headers.sh
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/usr/bin/env bash
 # SPDX-License-Identifier: GPL-2.0
 
 YELLOW='\033[0;33m'
